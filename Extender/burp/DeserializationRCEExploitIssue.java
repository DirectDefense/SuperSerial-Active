/*
	DeserializationRCEExploitIssue.java
	
	v0.5 (11/22/2016)
	
	Custom Burp Scan Issue for a successful Java Deserialization Remote Code Execution vulnerability detection. Includes details (in the Issue Detail section) of how the 
	exploit payload was generated and sent, as well as details about how the vulnerability was detected and details about the target system (web server platform and 
	operating system). This is an abstract parent class intended to be extended by more specific IScanIssue classes (current sub-classes: BinaryScanIssue.java and 
	EncodedScanIssue.java).
*/

package burp;

import java.net.URL;
import java.util.Properties;
import java.util.Set;

abstract class DeserializationRCEExploitIssue implements IScanIssue {
	//IScanIssue fields
	private IHttpRequestResponse[] httpMessages;
	private IHttpService httpService;
	private String remediationBackground;
	private URL url;
	
	private IBurpExtenderCallbacks callbacks;
	private IExtensionHelpers helpers;
	
	private static final String ISSUE_BACKGROUND = "Java Deserialization Remote Code Execution vulnerabilities occur when an application fails to properly validate user-supplied Java serialized data prior to deserialization. Just like any other HTTP request, all user-controlled input must be validated on the server side. If the application does not validate that the serialized object can be safely deserialized, subsequent library methods within the class path can be leveraged for code execution by reading the object using the readObject() method.<br><br>The five primary libraries leveraged for further exploitation are: Apache Commons Collections (3.x and 4.x), Spring Beans/Core (4.x), Groovy (2.3.x). Apache Commons Beanutils and JRE (&lt;= 1.7u21).<br><br><b>Credit</b>: Credit is given to the presentation \"Marshalling Pickles - AppSec California 2015\" by Chris Frohoff & Gabrial Lawrence; Mattias Kaiser's presentation \"Exploiting Deserialization Vulnerabilities in Java\"; and the blog from Foxglove Security titled \"What Do WebLogic, WebSphere, JBoss, Jenkins, OpenNMS, and Your Application Have in Common. This Vulnerability\" for bringing this issue to our attention.";
	private static final String REM_BACKGROUND = "Each remediation effort may vary due to application functionality, limitations of the environment and the libraries being utilized. For all third provided software solutions such as JBoss, WebSphere, WebLogic, Jenkins and OpenNMS, contact the vendor for security update information. All other developed applications should override the resolveClass method from the ObjectInputStream class. The goal of overriding method is to limit the objects being deserialized to those that are expected or desired. All other objects being deserialized should be ignored and disposed of properly. The following tools can help assist in achieving this:<ul><li>NotSoSerial: <a href=\"https://github.com/kantega/notsoserial\">https://github.com/kantega/notsoserial</a></li><li>SerialKiller: <a href=\"https://github.com/ikkisoft/SerialKiller\">https://github.com/ikkisoft/SerialKiller</a></li></ul><br>More details can be read in the following article entitled \"Look-ahead Java deserialization\" written in January 2013: <a href=\"http://www.ibm.com/developerworks/library/se-lookahead/\">http://www.ibm.com/developerworks/library/se-lookahead/</a>";
	
	DeserializationRCEExploitIssue(IBurpExtenderCallbacks cb,IHttpRequestResponse exploitRR,IHttpRequestResponse nodeRR) {
		callbacks = cb;
		helpers = callbacks.getHelpers();
		url = helpers.analyzeRequest(exploitRR).getUrl();
		httpService = exploitRR.getHttpService();
		if(nodeRR == null) {
			httpMessages = new IHttpRequestResponse[] {exploitRR};
		} else {
			httpMessages = new IHttpRequestResponse[] {exploitRR,nodeRR};
		}
	}
	
	protected String constructIssueDetail(String detail,Properties props) {
		Set<String> nameSet = props.stringPropertyNames();
		String[] nameArr = new String[nameSet.size()];
		String[] propNames = nameSet.toArray(nameArr);
		for(int i=0;i<propNames.length;i++) {
			String propVal = props.getProperty(propNames[i]);
			if(propVal!=null) {
				detail = detail.replace("["+propNames[i].toUpperCase()+"]",propVal);
			}
		}
		return detail;
	}
	
	
	//IScanIssue methods
	@Override
	public String getConfidence() {
		return "Certain";
	}
	
	@Override
	public IHttpRequestResponse[] getHttpMessages() {
		return httpMessages;
	}
	
	@Override
	public IHttpService getHttpService() {
		return httpService;
	}
	
	@Override
	public String getIssueBackground() {
		return ISSUE_BACKGROUND;
	}
	
	@Override
	public abstract String getIssueDetail();
	
	@Override
	public String getIssueName() {
		return "Java Deserialization Remote Code Execution";
	}
	
	@Override
	public int getIssueType() {
		return 0;
	}
	
	@Override
	public String getRemediationBackground() {
		return REM_BACKGROUND;
	}
	
	@Override
	public String getRemediationDetail() {
		return null;
	}
	
	@Override
	public String getSeverity() {
		return "High";
	}
	
	@Override
	public URL getUrl() {
		return url;
	}
}
