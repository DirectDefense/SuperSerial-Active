/*
	SuperSerialNodeHttpHandler.java
	
	v0.5 (11/22/2016)
	
	Handler for custom contexts that are generated by requests made to the /queue context. Allows a single file to be uploaded (via PUT request)
	or a single access entry (via GET request with URL parameter write=true) to be recorded. Allows uploaded file or access entry to be
	downloaded (via GET request). Finally, allows generated path that the SuperSerialNodeHttpHandler is register with to be removed from the Node 
	(via DELETE request). All requests require the randomly-generated authentication token GUID (generated by the SuperSerialNode class
	at execution start) to be included as a URL parameter.
	
	accepted url-parameters:
		(all HTTP methods):
			token (required): authentication token GUID
			technique: intented to be ysoserial payload type (but any input is accepted)
		(GET method):
			write (optional): whether to download uploaded file/access entry (false) or record access entry (true)
*/

package superserial.node;

//regular includes
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.Headers;
import com.sun.net.httpserver.HttpContext;
import com.sun.net.httpserver.HttpServer;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.FileOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.Date;
import java.util.Hashtable;
import java.net.URI;
import java.text.SimpleDateFormat;

//third-party includes
import org.json.JSONObject;
import org.json.JSONException;

public class SuperSerialNodeHttpHandler implements HttpHandler {
	private String token; //authentication token submitted
	private String path; //the actual path where the context is hosted
	private File tempPath; //local folder used store single uploaded file and access entry
	private File tempFile; //local file used to store uploaded file (or access entry if no file uploaded)
	private File tempAccessFile; //local file used to store access entry (for uploaded files)
	private boolean written; //whether data was written to local file
	private boolean uploaded; //whether data written to local file was an uploaded file (true) or an access entry (false)
	private String source; //hostname (or IP) of client that uploaded the file
	private String time; //time that file was uploaded
	private String technique; //ysoserial payload type used
	private String tempDir; //system directory where uploaded files/access entries will be saved
	
	public SuperSerialNodeHttpHandler(String t,String np,String tp) {
		token = t;
		path = np;
		tempFile = null;
		written = false;
		uploaded = false;
		source = null;
		time = null;
		technique = null;
		tempDir = tp;
	}
	
	public SuperSerialNodeHttpHandler(String t,String np,String tp,boolean u) {
		token = t;
		path = np;
		tempDir = tp;
		written = true;
		uploaded = u;
		if(uploaded) { //uploaded file found
			tempPath = new File(tempDir,"SuperSerial-UF-"+path.substring(1)+".tmp");
			if(tempPath.isDirectory()) { //directory found: get remaining files from discovered files; TODO: error check if files in directory actually exist
				tempFile = new File(tempPath,path.substring(1)+".file");
				tempAccessFile = new File(tempPath,path.substring(1)+".access");
				ByteArrayOutputStream baos = null;
				try {
					FileInputStream fis = new FileInputStream(tempAccessFile);
					baos = new ByteArrayOutputStream();
					byte[] buffer = new byte[1024];
					
					int nRead = fis.read(buffer,0,buffer.length);
					while(nRead != -1) {
						baos.write(buffer,0,nRead);
						nRead = fis.read(buffer,0,buffer.length);
					}
					baos.flush();
					baos.close();
					fis.close();
				} catch(Exception e) {
					e.printStackTrace();
					return;
				}
				
				JSONObject accessJSON = new JSONObject(new String(baos.toByteArray()));
				try {
					source = accessJSON.getString("accessSource");
				} catch(JSONException je) {
					source = null;
				}
				try {
					time = accessJSON.getString("accessTime");
				} catch(JSONException je) {
					time = null;
				}
				try {
					technique = accessJSON.getString("accessTechnique");
				} catch(JSONException je) {
					technique = null;
				}
			} else { //file found (backwards compatibility)
				tempFile = tempPath;
				tempPath = null;
				tempAccessFile = null;
				source = null;
				time = null;
				technique = null;
			}
			
		} else { //access entry found
			tempPath = null;
			tempAccessFile = null;
			tempFile = new File(tempDir,"SuperSerial-AE-"+path.substring(1)+".tmp");
		}
	}
	
	public void handle(HttpExchange exchange) {
		Date currTime = new Date(); //current time to be used as upload time (if file is successfully uploaded)
		try {
			String method = exchange.getRequestMethod();
			//SuperSerialNodeHelper.printLogEntry(method+" request received by "+path+" from "+exchange.getRemoteAddress().getHostString());
			
			URI uri = exchange.getRequestURI();
			Headers reqHeaders = exchange.getRequestHeaders();
			String clientToken = null;
			Hashtable<String,String> urlParams = SuperSerialNodeHelper.parseURLParams(uri.getQuery());
			if((urlParams!=null) && urlParams.containsKey("token")) {
				clientToken = urlParams.get("token");
			}
			
			InputStream is = null; //request body
			OutputStream os = null; //response body
			ByteArrayOutputStream baos = null;
			
			if(token.equalsIgnoreCase(clientToken)) {
				JSONObject retJson = new JSONObject();
				switch(method) {
					case "PUT": //upload a file
						String jsonStr = null;
						if((tempFile == null) && (!written)) { //if no file has been already uploaded, read file from request
							is = exchange.getRequestBody();
							baos = new ByteArrayOutputStream();
							byte[] buffer = new byte[1024];
							
							//read PUTted file from request and write to memory
							int nRead = is.read(buffer,0,buffer.length);
							while(nRead != -1) {
								baos.write(buffer,0,nRead);
								nRead = is.read(buffer,0,buffer.length);
							}
							baos.flush();
							baos.close();
							is.close();
							
							//save PUTted file to temporary file
							byte[] fileArray = baos.toByteArray();
							tempPath = new File(tempDir,"SuperSerial-UF-"+path.substring(1)+".tmp");
							tempPath.mkdir();
							tempFile = new File(tempPath,path.substring(1)+".file");
							FileOutputStream fos = new FileOutputStream(tempFile);
							fos.write(fileArray);
							fos.flush();
							fos.close();
							
							//set all fields for context
							written = true;
							uploaded = true;
							source = exchange.getRemoteAddress().getHostString(); //TODO: somehow save upload source for resuming (in temp file?); TODO: save DNS name (if available)
							time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(currTime); //TODO: somehow save upload time for resuming (in temp file?)
							if((urlParams!=null) && urlParams.containsKey("technique")) {
								technique=urlParams.get("technique");
							}
							
							//save fields to temporary file
							tempAccessFile = new File(tempPath,path.substring(1)+".access");
							fos = new FileOutputStream(tempAccessFile);
							fos.write(createAccessEntryJSONString().getBytes());
							fos.flush();
							fos.close();
							SuperSerialNodeHelper.printLogEntry("File (size: "+fileArray.length+" bytes) uploaded successfully to "+path+" by "+source);
							
							//return successful response
							retJson.put("status","Success");
							jsonStr = retJson.toString();
							Headers respHeaders = exchange.getResponseHeaders();
							respHeaders.add("Content-Type","application/json");
							exchange.sendResponseHeaders(200,jsonStr.length());
							os = exchange.getResponseBody();
							os.write(jsonStr.getBytes());
							os.flush();
							os.close();
						} else { //if file has already been uploaded (or access entry written), return failure response
							exchange.getRequestBody().close();
							
							//return failure response
							retJson.put("status","Failure: file already uploaded");
							jsonStr = retJson.toString();
							SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (file already uploaded or access entry already written)");
							Headers respHeaders = exchange.getResponseHeaders();
							respHeaders.add("Content-Type","application/json");
							exchange.sendResponseHeaders(500,jsonStr.length());
							os = exchange.getResponseBody();
							os.write(jsonStr.getBytes());
							os.flush();
							os.close();
						}
						break;
					case "GET": //retrieve uploaded file or write access entry (if write parameter as write=true is provided in URL)
						
						//check for write parameter
						boolean write=false;
						if((urlParams!=null) && urlParams.containsKey("write")) {
							write=Boolean.parseBoolean(urlParams.get("write"));
						}
						
						if(!write) { //if request is to read uploaded file
							if((tempFile != null) && (written)) { //if a file is ready for reading
								exchange.getRequestBody().close();
								
								//read temporary file into memory
								FileInputStream fis = new FileInputStream(tempFile);
								baos = new ByteArrayOutputStream();
								byte[] buffer = new byte[1024];
								
								int nRead = fis.read(buffer,0,buffer.length);
								while(nRead != -1) {
									baos.write(buffer,0,nRead);
									nRead = fis.read(buffer,0,buffer.length);
								}
								baos.flush();
								baos.close();
								fis.close();
								byte[] fileArray = baos.toByteArray();
								
								//check if file was uploaded or if context was accessed only, then submit response headers
								Headers respHeaders = exchange.getResponseHeaders();
								if(uploaded) { //file was uploaded: add source and upload time to response headers
									if(source != null) { //check that source is set (resumed contexts do not have a set source)
										respHeaders.add("Upload-Source",source);
									}
									if(time != null) { //check that time is set (resumed contexts do not have a set time)
										respHeaders.add("Upload-Time",time);
									}
									if(technique != null) { //check that technique is set (resumed contexts do not have a set technique)
										respHeaders.add("YSoSerial-Technique",technique);
									}
								} else { //no file was uploaded: add content-type to response headers
									respHeaders.add("Content-Type","application/json");
								}
								exchange.sendResponseHeaders(200,fileArray.length);
								
								//write temporary file to response
								os = exchange.getResponseBody();
								os.write(fileArray);
								os.flush();
								os.close();
								if(uploaded) {
									SuperSerialNodeHelper.printLogEntry("File (size: "+fileArray.length+" bytes) downloaded successfully from "+path+" by "+exchange.getRemoteAddress().getHostString());
								} else {
									SuperSerialNodeHelper.printLogEntry("Access entry downloaded successfully from "+path+" by "+exchange.getRemoteAddress().getHostString());
								}
								
							} else { //if no file was written, return failure response
								exchange.getRequestBody().close();
								
								//return failure response
								retJson.put("status","Failure: no file uploaded");
								jsonStr = retJson.toString();
								SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (no file or access entry to download)");
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(500,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							}
						} else { //write parameter supplied and true: write access entry to file
							if((tempFile == null) && (!written)) { //if no file has been already uploaded
								source = exchange.getRemoteAddress().getHostString(); //TODO: save DNS name (if available)
								time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(currTime);
								if((urlParams!=null) && urlParams.containsKey("technique")) {
									technique=urlParams.get("technique");
								}
								tempPath = null;
								tempAccessFile = null;
								tempFile = new File(tempDir,"SuperSerial-AE-"+path.substring(1)+".tmp");
								FileOutputStream fos = new FileOutputStream(tempFile);
								
								//write access entry JSON to file
								fos.write(createAccessEntryJSONString().getBytes());
								fos.flush();
								fos.close();
								written = true;
								SuperSerialNodeHelper.printLogEntry("Access entry successfully written to "+path+" by "+source);
								
								//return successful response
								retJson.put("status","Success");
								jsonStr = retJson.toString();
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(200,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							} else { //if another file or access entry has been written: return failure response
								exchange.getRequestBody().close();
								
								//return failure response
								retJson.put("status","Failure: file already uploaded");
								jsonStr = retJson.toString();
								SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (file already uploaded or access entry already written)");
								Headers respHeaders = exchange.getResponseHeaders();
								respHeaders.add("Content-Type","application/json");
								exchange.sendResponseHeaders(500,jsonStr.length());
								os = exchange.getResponseBody();
								os.write(jsonStr.getBytes());
								os.flush();
								os.close();
							}
						}
						break;
					case "DELETE": //remove context
						HttpContext context = exchange.getHttpContext();
						HttpServer server = context.getServer();
						exchange.getRequestBody().close();
						retJson.put("status","Success");
						retJson.put("message","context "+context.getPath()+" removed.");
						jsonStr = retJson.toString();
						exchange.sendResponseHeaders(200,jsonStr.length());
						os = exchange.getResponseBody();
						os.write(jsonStr.getBytes());
						os.flush();
						os.close();
						server.removeContext(context);
						SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" succeeded, "+path+" context removed!");
						break;
					case "BITS_POST": //BITS upload request (not yet implemented)
					default: //unsupported method: reject request with HTTP 405 response
						exchange.getRequestBody().close();
						exchange.sendResponseHeaders(405,-1);
						//exchange.getResponseBody().close();
						SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (unsupported HTTP method: "+method+")");
						break;
				}
			} else {
				exchange.getRequestBody().close();
				exchange.sendResponseHeaders(401,0);
				exchange.getResponseBody().close();
				SuperSerialNodeHelper.printLogEntry(method+" request from "+exchange.getRemoteAddress().getHostString()+" to "+path+" denied (wrong authentication token)");
			}
			
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}
	
	private String createAccessEntryJSONString() {
		JSONObject entry = new JSONObject();
		if(source!=null) entry.put("accessSource",source);
		if(time!=null) entry.put("accessTime",time);
		if(technique!=null) entry.put("accessTechnique",technique);
		if(entry.length()==0) {
			return null;
		}
		return entry.toString();
	}
}
